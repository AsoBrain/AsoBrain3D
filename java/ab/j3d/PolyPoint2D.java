/*
 * $Id$
 *
 * (C) Copyright Numdata BV 2000-2003 - All Rights Reserved
 *
 * This software may not be used, copied, modified, or distributed in any
 * form without express permission from Numdata BV. Please contact Numdata BV
 * for license information.
 */
package com.numdata.soda;

import ab.light3d.Matrix3D;

import com.numdata.oss.TextTools;

/**
 * This class describes a polyline control point in 2D.
 *
 * @author	Peter S. Heijnen
 * @author	Sjoerd Bouwman
 * @version $Revision$ ($Date$, $Author$)
 */
public final class PolyPoint2D
{
	/**
	 * Tolerance for almostEquals() method.
	 *
	 * @see	#almostEquals
	 */
	public static final float ALMOST = 0.0001f;

	/**
	 * X coordinate of control point.
	 */
	public final float x;

	/**
	 * Y coordinate of control point.
	 */
	public final float y;

	/**
	 * Construct new control point.
	 *
	 * @param	x	X coordinate of control point.
	 * @param	y	Y coordinate of control point.
	 */
	public PolyPoint2D( final float x , final float y )
	{
		this.x = x;
		this.y = y;
	}

	/**
	 * Test if the specified point is 'almost equal to' this point. The
	 * other point must have the same coordinates with a extremely small
	 * tolerance.
	 *
	 * @param	other	Point to compare with.
	 *
	 * @return	<CODE>true</CODE> if the specified point is 'almost' equal;
	 * 			<CODE>false</CODE> if the specified point is different.
	 */
	public boolean almostEquals( final PolyPoint2D other )
	{
		return almostEquals( other , ALMOST );
	}

	/**
	 * Test if the specified point is 'almost equal to' this point. The
	 * other point must have the same coordinates as this one with the
	 * specified tolerance.
	 *
	 * @param	other		Point to compare with.
	 * @param	tolerance	Acceptable tolerance.
	 *
	 * @return	<CODE>true</CODE> if the specified point is 'almost' equal;
	 * 			<CODE>false</CODE> if the specified point is different.
	 */
	public boolean almostEquals( final PolyPoint2D other , final float tolerance )
	{
		if ( other == null ) return false;
		if ( other == this ) return true;

		float d;
		return ( ( d = x - other.x ) > -tolerance ) && ( d < tolerance )
		    && ( ( d = y - other.y ) > -tolerance ) && ( d < tolerance );
	}

	/**
	 * Test for equality between this control point and the specified one.
	 *
	 * @param	other	Control point to compare with.
	 *
	 * @return	<CODE>true</CODE> if the control points are equals;
	 *			<CODE>false</CODE> otherwise.
	 */
	public boolean equals( final PolyPoint2D other )
	{
		return x == other.x && y == other.y;
	}

	/**
	 * Test for equality between this control point and the specified object.
	 * If the other object is a PolyPoint2D, this call is forwarded to
	 * #equals(PolyPoint2D).
	 *
	 * @param	other	Object to compare with.
	 *
	 * @return	<CODE>true</CODE> if the specified object is equal to this;
	 *			<CODE>false</CODE> otherwise.
	 */
	public boolean equals( final Object other )
	{
		return ( other instanceof PolyPoint2D ) && equals( (PolyPoint2D)other );
	}

    /**
     * Returns a hash code for this object.
     *
     * @return	Hash code value for this object.
     */
    public int hashCode()
	{
		return Float.floatToIntBits( x ) ^ Float.floatToIntBits( y );
    }

	/**
	 * Get length of segment of which this is the end point, and the specified argument
	 * represents the start point.
	 *
	 * @param	start	PolyPoint2D instance that defines the start point.
	 *
	 * @return	Length of segment.
	 */
	public float getLength( final PolyPoint2D start )
	{
		if ( almostEquals( start ) )
			return 0;

		final float dx = x - start.x;
		final float dy = y - start.y;

		return (float)Math.sqrt( dx * dx + dy * dy );
	}

	/**
	 * Construct point from string representation that was previously
	 * generated by the toString() method.
	 *
	 * @param	str		String representation of point.
	 *
	 * @return	Point that was created (may be <CODE>null</CODE>).
	 */
	public static PolyPoint2D createInstance( final String str )
	{
		if ( str == null || str.length() == 0 )
			throw new IllegalArgumentException( "invalid point specification: " + str );

		final String[] tokens = TextTools.tokenize( str , ',' );
		if ( tokens.length < 2 )
			throw new IllegalArgumentException( "insufficient tokens in specification: " + str );

		final String type = tokens[ 0 ];

		if ( "L".equals( type ) )
		{
			if ( tokens.length != 3 )
				throw new IllegalArgumentException( "invalid token count in line specification: " + str );

			return new PolyPoint2D( Float.parseFloat( tokens[ 1 ] ) , Float.parseFloat( tokens[ 2 ] ) );
		}
		else
		{
			throw new IllegalArgumentException( "unrecognized point type: " + type );
		}
	}

	/**
	 * Get string representation of this object.
	 *
	 * @return	String representing this object.
	 */
	public synchronized String toString()
	{
		return new StringBuffer()
						.append( "L," )
						.append( x )
						.append( "," )
						.append( y )
						.toString();
	}

	/**
	 * This method transforms this control point using the specified transformation
	 * matrix.
	 *
	 * @param	xform	Transformation matrix to apply.
	 *
	 * @return	PolyPoint2D resulting from transformation (may return this instance
	 *			if the transformation has no effect).
	 */
	protected PolyPoint2D transform( final Matrix3D xform )
	{
		if ( xform == null )
			return this;

		final float tx = x * xform.xx + y * xform.xy + xform.xo;
		final float ty = x * xform.yx + y * xform.yy + xform.yo;

		if ( tx == x && ty == y )
			return this;

		return new PolyPoint2D( tx , ty );
	}

}
