/* $Id$
 * ====================================================================
 * (C) Copyright Numdata BV 2005-2009
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * ====================================================================
 */
package ab.j3d.control;

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;

import ab.j3d.*;
import ab.j3d.geom.*;
import ab.j3d.model.*;
import ab.j3d.view.*;
import com.numdata.oss.event.*;

/**
 * This event used to define input from a user. It is normally generated by a
 * {@link ViewControlInput} and acted upon by {@link Control}s.
 * <p />
 * This class should provide all relevant data related to the user input,
 * including
 *
 * There are methods to return the X and Y coordinates of the mouse location,
 * the button that was pressed and the faces that are beneath the mouse in the
 * view component.
 *
 * @see     Control
 * @see     ViewControlInput
 *
 * @author  Mart Slot
 * @version $Revision$ $Date$
 */
public class ControlInputEvent
	extends EventObject
{
	/**
	 * This is a mask for the {@link InputEvent#getModifiersEx()} result to
	 * filter out only known modifiers.
	 */
	public static final int SUPPORTED_MODIFIERS =
		InputEvent.SHIFT_DOWN_MASK |
		InputEvent.CTRL_DOWN_MASK |
		InputEvent.META_DOWN_MASK |
		InputEvent.ALT_DOWN_MASK |
		InputEvent.BUTTON1_DOWN_MASK |
		InputEvent.BUTTON2_DOWN_MASK |
		InputEvent.BUTTON3_DOWN_MASK |
		InputEvent.ALT_GRAPH_DOWN_MASK;

	/**
	 * Scene input translator that caused this event. The translator may be
	 * used to request additional information on-demand.
	 */
	private final ViewControlInput _controlInput;

	/**
	 * The original mouse event.
	 */
	private InputEvent _inputEvent;

	/**
	 * The event sequence number. After each {@link MouseEvent#MOUSE_RELEASED}
	 * event, this number is increased. This makes it easy to see if for example
	 * a mouse press and a mouse release event are from the same mouse click.
	 */
	private int _sequenceNumber;

	/**
	 * Wether the mouse has been dragged since the button was pressed.
	 */
	private boolean _wasDragged;

	/**
	 * X coordinate of pointer when drag operation was started.
	 */
	private int _dragStartX;

	/**
	 * X coordinate of pointer when drag operation was started.
	 */
	private int _dragStartY;

	/**
	 * A list of {@link Face3DIntersection}s of all objects beneath the mouse pointer
	 * in the 3D world.
	 */
	private List<Face3DIntersection> _intersections;

	/**
	 * Ray from pointer into view volume (WCS). Calculated on-demand.
	 *
	 * @see     #getPointerRay
	 */
	private Ray3D _pointerRay;

	/**
	 * Serialversion UID.
	 */
	private static final long serialVersionUID = 2165278808002714887L;

	/**
	 * Creates a new mouse control event.
	 *
	 * @param   controlInput    The control input on which this event occured.
	 * @param   inputEvent      The original {@link InputEvent}.
	 * @param   sequenceNumber  The sequence number of this event.
	 * @param   wasDragged      Wether or not the mouse has been dragged
	 *                          since it was pressed.
	 * @param   dragStartX      X coordinate where drag started (pixel).
	 * @param   dragStartY      Y coordinate where drag started (pixel).
	 *
	 * @throws  NullPointerException if <code>event</code> is <code>null</code>.
	 */
	public ControlInputEvent( final ViewControlInput controlInput , final InputEvent inputEvent , final int sequenceNumber , final boolean wasDragged , final int dragStartX , final int dragStartY )
	{
		super( controlInput );

		_controlInput   = controlInput;
		_inputEvent     = inputEvent;
		_sequenceNumber = sequenceNumber;
		_wasDragged     = wasDragged;
		_dragStartX     = dragStartX;
		_dragStartY     = dragStartY;

		_pointerRay    = null;
		_intersections = null;
	}

	/**
	 * The {@link ViewControlInput} this event came from.
	 *
	 * @return  {@link ViewControlInput} this event came from.
	 */
	public ViewControlInput getSource()
	{
		return (ViewControlInput)super.getSource();
	}

	/**
	 * Get {@link Component} from which the input event was received.
	 *
	 * @return  {@link Component} from which the input event was received.
	 */
	public Component getSourceComponent()
	{
		return (Component)_inputEvent.getSource();
	}

	/**
	 * Get delta X relative to start of drag operation in pixels.
	 *
	 * @return  Delta X relative to start of drag operation in pixels.
	 */
	public int getDragDeltaX()
	{
		return getX() - _dragStartX;
	}

	/**
	 * Get delta Y relative to start of drag operation in pixels.
	 *
	 * @return  Delta Y relative to start of drag operation in pixels.
	 */
	public int getDragDeltaY()
	{
		return getY() - _dragStartY;
	}

	/**
	 * Get start X coordinate of drag operation (pixels).
	 *
	 * @return  Start X coordinate of drag operation (pixels).
	 */
	public int getDragStartX()
	{
		return _dragStartX;
	}

	/**
	 * Get start Y coordinate of drag operation (pixels).
	 *
	 * @return  Start Y coordinate of drag operation (pixels).
	 */
	public int getDragStartY()
	{
		return _dragStartY;
	}

	/**
	 * Returns the {@link EventDispatcher} that was used to dispatch this event.
	 *
	 * @return  The {@link EventDispatcher} that dispatched this event.
	 */
	public EventDispatcher getEventDispatcher()
	{
		return _controlInput.getEventDispatcher();
	}

	/**
	 * Returns the value returned by {@link java.awt.AWTEvent#getID()} for the
	 * encapsulated event.
	 *
	 * @return  The event type.
	 */
	public int getID()
	{
		return _inputEvent.getID();
	}

	/**
	 * Returns a {@link List} of {@link Face3DIntersection}s of all objects beneath
	 * the mousepointer in the 3D world.
	 *
	 * @return  The faces beneath the mouse
	 */
	public List<Face3DIntersection> getIntersections()
	{
		List<Face3DIntersection> result = _intersections;
		if ( result == null )
		{
			result = _controlInput.getIntersections( getPointerRay() );
			_intersections = result;
		}

		return result;
	}

	/**
	 * Get input event.
	 *
	 * @return  {@link InputEvent} (never <code>null</code>).
	 */
	public InputEvent getInputEvent()
	{
		return _inputEvent;
	}

	/**
	 * Get supported modifiers. This returns only the supported bits (see
	 * {@link #SUPPORTED_MODIFIERS} from {@link InputEvent#getModifiersEx()}.
	 * This allows testing by equality to easily rule out any unwanted modifiers.
	 *
	 * @return  Supported modifiers from input event.
	 */
	public int getSupportedModifiers()
	{
		return ( _inputEvent.getModifiersEx() & SUPPORTED_MODIFIERS );
	}

	/**
	 * Get mouse event, if available.
	 *
	 * @return  {@link MouseEvent};
	 *          <code>null</code> if no {@link MouseEvent} is available.
	 */
	public MouseEvent getMouseEvent()
	{
		return ( _inputEvent instanceof MouseEvent ) ? (MouseEvent)_inputEvent : null;
	}

	/**
	 * Get button, if any, that is currently down. If multiple mouse buttons
	 * are down, the first one is returned.
	 *
	 * @return  Button that is down (<code>1</code> = first);
	 *          <code>0</code> if no button is down.
	 */
	public int getMouseButtonDown()
	{
		final int modifiers = _inputEvent.getModifiersEx();

		return ( ( modifiers & InputEvent.BUTTON1_DOWN_MASK ) != 0 ) ? 1 :
		       ( ( modifiers & InputEvent.BUTTON2_DOWN_MASK ) != 0 ) ? 2 :
		       ( ( modifiers & InputEvent.BUTTON3_DOWN_MASK ) != 0 ) ? 3 : 0;
	}

	/**
	 * Get ray from pointer into view volume, defined in world coordinates.
	 *
	 * @return  Ray from pointer into view volume (WCS).
	 *
	 * @see     Projector#getPointerRay
	 */
	public Ray3D getPointerRay()
	{
		Ray3D result = _pointerRay;
		if ( result == null )
		{
			if ( _inputEvent instanceof MouseEvent )
			{
				final MouseEvent mouseEvent = (MouseEvent)_inputEvent;

				final Projector    projector    = getProjector();
				final Matrix3D     world2view   = getScene2View();
				final Matrix3D     view2world   = world2view.inverse();

				result = projector.getPointerRay( view2world , (double)mouseEvent.getX() , (double)mouseEvent.getY() );
				_pointerRay = result;
			}
		}

		return result;
	}

	/**
	 * Get {@link Projector} that was used to project the 3D scene onto the
	 * 2D image.
	 *
	 * @return  {@link Projector} used project the 3D scene onto the 2D image.
	 */
	public Projector getProjector()
	{
		return _controlInput.getProjector();
	}

	/**
	 * Get sequence number of this event. After each MOUSE_RELEASED event, this
	 * number is increased. This makes it easy to see if for example a mouse
	 * press and a mouse release event are from the same mouse click.
	 *
	 * @return  The number of this event.
	 */
	public int getSequenceNumber()
	{
		return _sequenceNumber;
	}

	/**
	 * Get view transform.
	 *
	 * @return  Transform from scene to view coordinates.
	 */
	public Matrix3D getScene2View()
	{
		return _controlInput.getScene2View();
	}

	/**
	 * Get view transform.
	 *
	 * @return  Transform from view to scene coordinates.
	 */
	public Matrix3D getView2Scene()
	{
		return _controlInput.getView2Scene();
	}

	/**
	 * Returns the X coordinate of the mouse location for this event.
	 *
	 * @return  X coordinate of the mouse location;
	 *          -1 if no mouse location is available for this event.
	 */
	public int getX()
	{
		final MouseEvent mouseEvent = getMouseEvent();
		return ( mouseEvent != null ) ? mouseEvent.getX() : -1;
	}

	/**
	 * Returns the Y coordinate of the mouse location for this event.
	 *
	 * @return  Y coordinate of the mouse location;
	 *          -1 if no mouse location is available for this event.
	 */
	public int getY()
	{
		final MouseEvent mouseEvent = getMouseEvent();
		return ( mouseEvent != null ) ? mouseEvent.getY() : -1;
	}

	/**
	 * Returns whether or not the Alt modifier is down on this event.
	 *
	 * @return  whether or not the Alt modifier is down on this event.
	 */
	public boolean isAltDown()
	{
		return _inputEvent.isAltDown() || _inputEvent.isMetaDown();
	}

	/**
	 * Returns whether or not the Control modifier is down on this event.
	 *
	 * @return  whether or not the Control modifier is down on this event.
	 */
	public boolean isControlDown()
	{
		return _inputEvent.isControlDown();
	}

	/**
	 * Returns whether or not mouse button #1 is down on this event.
	 *
	 * @return  <code>true</code> if mouse button #1 is down;
	 *          <code>false</code> otherwise.
	 */
	public boolean isMouseButton1Down()
	{
		return ( ( _inputEvent.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK ) != 0 );
	}

	/**
	 * Returns whether or not mouse button #2 is down on this event.
	 *
	 * @return  <code>true</code> if mouse button #2 is down;
	 *          <code>false</code> otherwise.
	 */
	public boolean isMouseButton2Down()
	{
		return ( ( _inputEvent.getModifiersEx() & MouseEvent.BUTTON2_DOWN_MASK ) != 0 );
	}

	/**
	 * Returns whether or not mouse button #3 is down on this event.
	 *
	 * @return  <code>true</code> if mouse button #3 is down;
	 *          <code>false</code> otherwise.
	 */
	public boolean isMouseButton3Down()
	{
		return ( ( _inputEvent.getModifiersEx() & MouseEvent.BUTTON3_DOWN_MASK ) != 0 );
	}

	/**
	 * Returns whether or not a mouse button is down on this event.
	 *
	 * @return  <code>true</code> if at least one mouse button is down;
	 *          <code>false</code> otherwise.
	 */
	public boolean isMouseButtonDown()
	{
		final int modifiers  = _inputEvent.getModifiersEx();
		final int buttonMask = MouseEvent.BUTTON1_DOWN_MASK | MouseEvent.BUTTON2_DOWN_MASK | MouseEvent.BUTTON3_DOWN_MASK;

		return ( ( modifiers & buttonMask ) != 0 );
	}

	/**
	 * Returns whether or not the Shift modifier is down on this event.
	 *
	 * @return  whether or not the Shift modifier is down on this event.
	 */
	public boolean isShiftDown()
	{
		return _inputEvent.isShiftDown();
	}

	/**
	 * Wether the mouse has been dragged since the button was pressed.
	 *
	 * @return  <code>true</code> if the mouse was dragged;
	 *          <code>false</code> if not.
	 */
	public boolean wasDragged()
	{
		return _wasDragged;
	}

	@Override
	public String toString()
	{
		return super.toString() + "[inputEvent=" + _inputEvent + "]";
	}
}
