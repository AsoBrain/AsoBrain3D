/* $Id$
 * ====================================================================
 * (C) Copyright Numdata BV 2005-2008
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * ====================================================================
 */
package ab.j3d.control;

import java.awt.Component;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.EventObject;
import java.util.List;

import ab.j3d.Matrix3D;
import ab.j3d.Vector3D;
import ab.j3d.geom.GeometryTools;
import ab.j3d.geom.Plane3D;
import ab.j3d.geom.Ray3D;
import ab.j3d.model.Face3DIntersection;
import ab.j3d.view.Projector;

import com.numdata.oss.event.EventDispatcher;

/**
 * This event used to define input from a user. It is normally generated by a
 * {@link ControlInput} and acted upon by {@link Control}s.
 * <p />
 * This class should provide all relevant data related to the user input,
 * including
 *
 * There are methods to return the X and Y coordinates of the mouse location,
 * the button that was pressed and the faces that are beneath the mouse in the
 * view component.
 *
 * @see     Control
 * @see     ControlInput
 *
 * @author  Mart Slot
 * @version $Revision$ $Date$
 */
public class ControlInputEvent
	extends EventObject
{
	/**
	 * Scene input translator that caused this event. The translator may be
	 * used to request additional information on-demand.
	 */
	private final ControlInput _controlInput;

	/**
	 * The original mouse event.
	 */
	private InputEvent _inputEvent;

	/**
	 * The event sequence number. After each {@link MouseEvent#MOUSE_RELEASED}
	 * event, this number is increased. This makes it easy to see if for example
	 * a mouse press and a mouse release event are from the same mouse click.
	 */
	private int _sequenceNumber;

	/**
	 * Wether the mouse has been dragged since the button was pressed.
	 */
	private boolean _wasDragged;

	/**
	 * X coordinate of pointer when drag operation was started.
	 */
	private int _dragStartX;

	/**
	 * X coordinate of pointer when drag operation was started.
	 */
	private int _dragStartY;

	/**
	 * A list of {@link Face3DIntersection}s of all objects beneath the mouse pointer
	 * in the 3D world.
	 */
	private List<Face3DIntersection> _intersections;

	/**
	 * Ray from pointer into view volume (WCS). Calculated on-demand.
	 *
	 * @see     #getPointerRay
	 */
	private Ray3D _pointerRay;

	/**
	 * Serialversion UID.
	 */
	private static final long serialVersionUID = 2165278808002714887L;

	/**
	 * Creates a new mouse control event.
	 *
	 * @param   controlInput    The control input on which this event occured.
	 * @param   inputEvent      The original {@link InputEvent}.
	 * @param   sequenceNumber  The sequence number of this event.
	 * @param   wasDragged      Wether or not the mouse has been dragged
	 *                          since it was pressed.
	 * @param   dragStartX      X coordinate where drag started (pixel).
	 * @param   dragStartY      Y coordinate where drag started (pixel).
	 *
	 * @throws  NullPointerException if <code>event</code> is <code>null</code>.
	 */
	public ControlInputEvent( final ControlInput controlInput , final InputEvent inputEvent , final int sequenceNumber , final boolean wasDragged , final int dragStartX , final int dragStartY )
	{
		super( controlInput );

		_controlInput   = controlInput;
		_inputEvent     = inputEvent;
		_sequenceNumber = sequenceNumber;
		_wasDragged     = wasDragged;
		_dragStartX     = dragStartX;
		_dragStartY     = dragStartY;

		_pointerRay    = null;
		_intersections = null;
	}

	/**
	 * Get {@link Component} from which the input event was received.
	 *
	 * @return  {@link Component} from which the input event was received.
	 */
	public Component getSourceComponent()
	{
		return (Component)_inputEvent.getSource();
	}

	/**
	 * Get number of times the mouse button was pressed.
	 *
	 * @return  Number of times the mouse button was pressed;
	 *          -1 if this event has no associated mouse button.
	 */
	public int getClickCount()
	{
		final MouseEvent mouseEvent = getMouseEvent();
		return ( mouseEvent != null ) ? mouseEvent.getClickCount() : -1;
	}

	/**
	 * Get delta X relative to start of drag operation in pixels.
	 *
	 * @return  Delta X relative to start of drag operation in pixels.
	 */
	public int getDragDeltaX()
	{
		return getX() - _dragStartX;
	}

	/**
	 * Get delta Y relative to start of drag operation in pixels.
	 *
	 * @return  Delta Y relative to start of drag operation in pixels.
	 */
	public int getDragDeltaY()
	{
		return getY() - _dragStartY;
	}

	/**
	 * Get start X coordinate of drag operation (pixels).
	 *
	 * @return  Start X coordinate of drag operation (pixels).
	 */
	public int getDragStartX()
	{
		return _dragStartX;
	}

	/**
	 * Get start Y coordinate of drag operation (pixels).
	 *
	 * @return  Start Y coordinate of drag operation (pixels).
	 */
	public int getDragStartY()
	{
		return _dragStartY;
	}

	/**
	 * Returns the {@link EventDispatcher} that was used to dispatch this event.
	 *
	 * @return  The {@link EventDispatcher} that dispatched this event.
	 */
	public EventDispatcher getEventDispatcher()
	{
		return _controlInput.getEventDispatcher();
	}

	/**
	 * Returns the value returned by {@link java.awt.AWTEvent#getID()} for the
	 * encapsulated event.
	 *
	 * @return  The event type.
	 */
	public int getID()
	{
		return _inputEvent.getID();
	}

	/**
	 * Returns a {@link List} of {@link Face3DIntersection}s of all objects beneath
	 * the mousepointer in the 3D world.
	 *
	 * @return  The faces beneath the mouse
	 */
	public List<Face3DIntersection> getIntersections()
	{
		List<Face3DIntersection> intersections = _intersections;
		if ( intersections == null )
		{
			intersections = _controlInput.getIntersections( getPointerRay() );
			_intersections = intersections;
		}

		return new ArrayList<Face3DIntersection>( intersections );
	}

	/**
	 * Returns the intersection point between the pointer ray and a plane. The
	 * point is returned as a {@link Vector3D}; however, if any of the following
	 * conditions is met, no intersection exists, and <code>null</code> will be
	 * returned:
	 * <ol>
	 *  <li>The ray is parallel to the plane;</li>
	 *  <li>The ray does not point in the plane's direction.</li>
	 * </ol>
	 *
	 * @param   plane   Plane to get intersection from.
	 *
	 * @return  Intersection-point between pointer ray and plane.
	 *
	 * @throws  NullPointerException if <code>plane</code> is <code>null</code>.
	 */
	public Vector3D getIntersectionWithPlane( final Plane3D plane )
	{
		return GeometryTools.getIntersectionBetweenRayAndPlane( plane , getPointerRay() );
	}

	/**
	 * Get mouse event, if available.
	 *
	 * @return  {@link MouseEvent};
	 *          <code>null</code> if no {@link MouseEvent} is available.
	 */
	public MouseEvent getMouseEvent()
	{
		return ( _inputEvent instanceof MouseEvent ) ? (MouseEvent)_inputEvent : null;
	}

	/**
	 * Get button, if any, that changed state.
	 *
	 * @return  Button that changed state ({@link MouseEvent#NOBUTTON},
	 *          {@link MouseEvent#BUTTON1}, {@link MouseEvent#BUTTON2}, or
	 *          {@link MouseEvent#BUTTON3}).
	 */
	public int getMouseButton()
	{
		final MouseEvent mouseEvent = getMouseEvent();
		return ( mouseEvent != null ) ? mouseEvent.getButton() : MouseEvent.NOBUTTON;
	}

	/**
	 * Get button, if any, that is currently down. If multiple mouse buttons
	 * are down, the first one is returned.
	 *
	 * @return  Button that is down (<code>1</code> = first);
	 *          <code>0</code> if no button is down.
	 */
	public int getMouseButtonDown()
	{
		final int modifiers = _inputEvent.getModifiersEx();

		return ( ( modifiers & InputEvent.BUTTON1_DOWN_MASK ) != 0 ) ? 1 :
		       ( ( modifiers & InputEvent.BUTTON2_DOWN_MASK ) != 0 ) ? 2 :
		       ( ( modifiers & InputEvent.BUTTON3_DOWN_MASK ) != 0 ) ? 3 : 0;
	}

	/**
	 * Get key code, if any, that caused the event.
	 *
	 * @return  Key code.
	 *
	 * @see     KeyEvent#getKeyCode()
	 */
	public int getKeyCode()
	{
		final InputEvent inputEvent = _inputEvent;
		return ( inputEvent instanceof KeyEvent ) ? ((KeyEvent)inputEvent).getKeyCode() : KeyEvent.VK_UNDEFINED;
	}

	/**
	 * Get ray from pointer into view volume, defined in world coordinates.
	 *
	 * @return  Ray from pointer into view volume (WCS).
	 *
	 * @see     Projector#getPointerRay
	 */
	public Ray3D getPointerRay()
	{
		Ray3D result = _pointerRay;

		final MouseEvent mouseEvent = getMouseEvent();

		if ( ( result == null ) && ( mouseEvent != null ) )
		{
			final Projector    projector    = getProjector();
			final Matrix3D     world2view   = getViewTransform();
			final Matrix3D     view2world   = world2view.inverse();

			result = projector.getPointerRay( view2world , (double)mouseEvent.getX() , (double)mouseEvent.getY() );
			_pointerRay = result;
		}

		return result;
	}

	/**
	 * Get {@link Projector} that was used to project the 3D scene onto the
	 * 2D image.
	 *
	 * @return  {@link Projector} used project the 3D scene onto the 2D image.
	 */
	public Projector getProjector()
	{
		return _controlInput.getProjector();
	}

	/**
	 * Get sequence number of this event. After each MOUSE_RELEASED event, this
	 * number is increased. This makes it easy to see if for example a mouse
	 * press and a mouse release event are from the same mouse click.
	 *
	 * @return  The number of this event.
	 */
	public int getSequenceNumber()
	{
		return _sequenceNumber;
	}

	/**
	 * Get transformation matrix to transform world to view coordinates.
	 *
	 * @return  Transfrom from world to view coordinates.
	 */
	public Matrix3D getViewTransform()
	{
		return _controlInput.getViewTransform();
	}

	/**
	 * Returns the X coordinate of the mouse location for this event.
	 *
	 * @return  X coordinate of the mouse location;
	 *          -1 if no mouse location is available for this event.
	 */
	public int getX()
	{
		final MouseEvent mouseEvent = getMouseEvent();
		return ( mouseEvent != null ) ? mouseEvent.getX() : -1;
	}

	/**
	 * Returns the Y coordinate of the mouse location for this event.
	 *
	 * @return  Y coordinate of the mouse location;
	 *          -1 if no mouse location is available for this event.
	 */
	public int getY()
	{
		final MouseEvent mouseEvent = getMouseEvent();
		return ( mouseEvent != null ) ? mouseEvent.getY() : -1;
	}

	/**
	 * Returns whether or not the Alt modifier is down on this event.
	 *
	 * @return  whether or not the Alt modifier is down on this event.
	 */
	public boolean isAltDown()
	{
		return _inputEvent.isAltDown() || _inputEvent.isMetaDown();
	}

	/**
	 * Returns whether or not the Control modifier is down on this event.
	 *
	 * @return  whether or not the Control modifier is down on this event.
	 */
	public boolean isControlDown()
	{
		return _inputEvent.isControlDown();
	}

	/**
	 * Returns whether or not mouse button #1 is down on this event.
	 *
	 * @return  <code>true</code> if mouse button #1 is down;
	 *          <code>false</code> otherwise.
	 */
	public boolean isMouseButton1Down()
	{
		return ( ( _inputEvent.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK ) != 0 );
	}

	/**
	 * Returns whether or not mouse button #2 is down on this event.
	 *
	 * @return  <code>true</code> if mouse button #2 is down;
	 *          <code>false</code> otherwise.
	 */
	public boolean isMouseButton2Down()
	{
		return ( ( _inputEvent.getModifiersEx() & MouseEvent.BUTTON2_DOWN_MASK ) != 0 );
	}

	/**
	 * Returns whether or not mouse button #3 is down on this event.
	 *
	 * @return  <code>true</code> if mouse button #3 is down;
	 *          <code>false</code> otherwise.
	 */
	public boolean isMouseButton3Down()
	{
		return ( ( _inputEvent.getModifiersEx() & MouseEvent.BUTTON3_DOWN_MASK ) != 0 );
	}

	/**
	 * Returns whether or not a mouse button is down on this event.
	 *
	 * @return  <code>true</code> if at least one mouse button is down;
	 *          <code>false</code> otherwise.
	 */
	public boolean isMouseButtonDown()
	{
		final int modifiers  = _inputEvent.getModifiersEx();
		final int buttonMask = MouseEvent.BUTTON1_DOWN_MASK | MouseEvent.BUTTON2_DOWN_MASK | MouseEvent.BUTTON3_DOWN_MASK;

		return ( ( modifiers & buttonMask ) != 0 );
	}

	/**
	 * Returns whether or not the Shift modifier is down on this event.
	 *
	 * @return  whether or not the Shift modifier is down on this event.
	 */
	public boolean isShiftDown()
	{
		return _inputEvent.isShiftDown();
	}

	/**
	 * Create a human readable representation of this {@link ControlInputEvent}. This
	 * is especially useful for debugging.
	 *
	 * @return  A human readable representation of this {@link ControlInputEvent}.
	 */
	public String toFriendlyString()
	{
		final StringBuilder sb = new StringBuilder();

		final List<Face3DIntersection> objectsUnderMouse = _intersections;

		sb.append( "ControlEvent\nType: " );
		switch ( getID() )
		{
			case MouseEvent.MOUSE_PRESSED :
				sb.append( "MOUSE_PRESSED" );
				break;

			case MouseEvent.MOUSE_RELEASED :
				sb.append( "MOUSE_RELEASED" );
				break;

			case MouseEvent.MOUSE_DRAGGED :
				sb.append( "MOUSE_DRAGGED" );
				break;

			case MouseEvent.MOUSE_MOVED :
				sb.append( "MOUSE_MOVED" );
				break;

			case MouseEvent.MOUSE_WHEEL :
				sb.append( "MOUSE_WHEEL" );
				break;

			default :
				sb.append( "???" );
		}

		sb.append( " \nEvent number: " );
		sb.append( _sequenceNumber );
		sb.append( " \nClicked: mouse button " );
		sb.append( getMouseButton() );
		sb.append( " at (" );
		sb.append( getX() );
		sb.append( " , " );
		sb.append( getY() );
		sb.append( ")\n" );
		sb.append( "Mouse has " );
		if ( !_wasDragged )
			sb.append( "not " );
		sb.append( " been dragged.\n" );
		sb.append( objectsUnderMouse.size() );
		sb.append( " Objects under the mouse: " );

		for ( final Object underMouse : objectsUnderMouse )
		{
			final Face3DIntersection intersection = (Face3DIntersection)underMouse;

			sb.append( "  Object ID " );
			sb.append( intersection.getObjectID() );
		}

		return sb.toString();
	}

	/**
	 * Wether the mouse has been dragged since the button was pressed.
	 *
	 * @return  <code>true</code> if the mouse was dragged;
	 *          <code>false</code> if not.
	 */
	public boolean wasDragged()
	{
		return _wasDragged;
	}
}
